<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Rust Push Component"><meta name="keywords" content="rust, rustlang, rust-lang, push"><title>push - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../push/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../push/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate push</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></div></ul><section><div class="block"><ul><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div></section><div id="sidebar-vars" data-name="push" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../push/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">push</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/push/lib.rs.html#5-474">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="rust-push-component"><a href="#rust-push-component">Rust Push Component</a></h2>
<p>This component helps an application to manage <a href="https://developer.mozilla.org/en-US/docs/Web/API/Push_API">WebPush</a> subscriptions,
acting as an intermediary between Mozilla’s <a href="https://autopush.readthedocs.io/en/latest/">autopush service</a>
and platform native push infrastructure such as <a href="https://firebase.google.com/docs/cloud-messaging">Firebase Cloud Messaging</a> or <a href="https://developer.amazon.com/docs/adm/overview.html">Amazon Device Messaging</a>.</p>
<h3 id="background-concepts"><a href="#background-concepts">Background Concepts</a></h3><h4 id="webpush-subscriptions"><a href="#webpush-subscriptions">WebPush Subscriptions</a></h4>
<p>A WebPush client manages a number of <em>subscriptions</em>, each of which is used to deliver push
notifications to a different part of the app. For example, a web browser might manage a separate
subscription for each website that has registered a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">service worker</a>, and an application that includes Firefox Accounts would manage
a dedicated subscription on which to receive account state updates.</p>
<p>Each subscription is identified by a unique <em>channel id</em>, which is a randomly-generated identifier.
It’s the responsibility of the application to know how to map a channel id to an appropriate function
in the app to receive push notifications. Subscriptions also have an associated <em>scope</em> which is something
to do which service workers that your humble author doesn’t really understand :-/.</p>
<p>When a subscription is created for a channel id, we allocate <em>subscription info</em> consisting of:</p>
<ul>
<li>An HTTP endpoint URL at which push messages can be submitted.</li>
<li>A cryptographic key and authentication secret with which push messages can be encrypted.</li>
</ul>
<p>This subscription info is distributed to other services that want to send push messages to
the application.</p>
<p>The HTTP endpoint is provided by Mozilla’s <a href="https://autopush.readthedocs.io/en/latest/">autopush service</a>,
and we use the <a href="https://github.com/mozilla/rust-ece">rust-ece</a> to manage encryption with the cryptographic keys.</p>
<p>Here’s a helpful diagram of how the <em>subscription</em> flow works at a high level across the moving parts:
<img src="https://mozilla.github.io/application-services/book/diagrams/Push-Component-Subscription-flow.png" alt="A Sequence diagram showing how the different parts of push interact" title="Sequence diagram" /></p>
<h4 id="autopush-bridging"><a href="#autopush-bridging">AutoPush Bridging</a></h4>
<p>Our target consumer platforms each have their own proprietary push-notification infrastructure,
such as <a href="https://firebase.google.com/docs/cloud-messaging">Firebase Cloud Messaging</a> for Android
and the <a href="https://developer.apple.com/notifications/">Apple Push Notification Service</a> for iOS.
Mozilla’s <a href="https://autopush.readthedocs.io/en/latest/">autopush service</a> provides a bridge between
these different mechanisms and the WebPush standard so that they can be used with a consistent
interface.</p>
<p>This component acts a client of the <a href="https://autopush.readthedocs.io/en/latest/http.html#push-service-bridge-http-interface">Push Service Bridge HTTP Interface</a>.</p>
<p>We assume two things about the consuming application:</p>
<ul>
<li>It has registered with the autopush service and received a unique <code>app_id</code> identifying this registration.</li>
<li>It has registred with whatever platform-specific notification infrastructure is appropriate, and is
able to obtain a <code>token</code> corresponding to its native push notification state.</li>
</ul>
<p>On first use, this component will register itself as an <em>application instance</em> with the autopush service, providing the <code>app_id</code> and <code>token</code> and receiving a unique <code>uaid</code> (“user-agent id”) to identify its
connection to the server.</p>
<p>As the application adds or removes subscriptions using the API of this component, it will:</p>
<ul>
<li>Manage a local database of subscriptions and the corresponding cryptographic material.</li>
<li>Make corresponding HTTP API calls to update the state associated with its <code>uaid</code> on the autopush server.</li>
</ul>
<p>Periodically, the application should call a special <code>verify_connection</code> method to check whether
the state on the autopush server matches the local state and take any corrective action if it
differs.</p>
<p>For local development and debugging, it is possible to run a local instance of the autopush
bridge service; see <a href="https://docs.google.com/document/d/18L_g2hIj_1mncF978A_SHXN4udDQLut5P_ZHYZEwGP8">this google doc</a> for details.</p>
<h3 id="api"><a href="#api">API</a></h3><h3 id="initialization"><a href="#initialization">Initialization</a></h3>
<p>Calls are handled by the <code>PushManager</code>, which provides a handle for future calls.</p>
<p>example:</p>
<div class="example-wrap"><pre class="language-kotlin"><code>
import mozilla.appservices.push.(PushManager, BridgeTypes)

// The following are mock calls for fetching application level configuration options.
// &quot;SenderID&quot; is the native OS push message application identifier. See Native
// messaging documentation for details.
val sender_id = SystemConfigurationOptions.get(&quot;SenderID&quot;)

// The &quot;bridge type&quot; is the identifier for the native OS push message system.
// (e.g. FCM for Google Firebase Cloud Messaging, ADM for Amazon Direct Messaging,
// etc.)
val bridge_type = BridgeTypes.FCM

// The &quot;registration_id&quot; is the native OS push message user registration number.
// Native push message registration usually happens at application start, and returns
// an opaque user identifier string. See Native messaging documentation for details.
val registration_id = NativeMessagingSystem.register(sender_id)

val push_manager = PushManager(
    sender_id,
    bridge_type,
    registration_id
)

// It is strongly encouraged that the connection is verified at least once a day.
// This will ensure that the server and UA have matching information regarding
// subscriptions. This call usually returns quickly, but may take longer if the
// UA has a large number of subscriptions and things have fallen out of sync.

for change in push_manager.verify_connection() {
    // fetch the subscriber from storage using the change[0] and
    // notify them with a `pushsubscriptionchange` message containing the new
    // endpoint change[1]
}
</code></pre></div><h3 id="new-subscription"><a href="#new-subscription">New subscription</a></h3>
<p>Before messages can be delivered, a new subscription must be requested. The subscription info block contains all the information a remote subscription provider service will need to encrypt and transmit a message to this user agent.</p>
<p>example:</p>
<div class="example-wrap"><pre class="language-kotlin"><code>
// Each new request must have a unique &quot;channel&quot; identifier. This channel helps
// later identify recipients and aid in routing. A ChannelID is a UUID4 value.
// the &quot;scope&quot; is the ServiceWorkerRegistration scope. This will be used
// later for push notification management.
val channelID = GUID.randomUUID()

val subscription_info = push_manager.subscribe(channelID, endpoint_scope)

// the published subscription info has the following JSON format:
// {&quot;endpoint&quot;: subscription_info.endpoint,
//  &quot;keys&quot;: {
//      &quot;auth&quot;: subscription_info.keys.auth,
//      &quot;p256dh&quot;: subscription_info.keys.p256dh
//  }}</code></pre></div><h3 id="end-a-subscription"><a href="#end-a-subscription">End a subscription</a></h3>
<p>A user may decide to no longer receive a given subscription. To remove a given subscription, pass the associated channelID</p>
<div class="example-wrap"><pre class="language-kotlin"><code>push_manager.unsubscribe(channelID)  // Terminate a single subscription</code></pre></div>
<p>If the user wishes to terminate all subscriptions, send and empty string for channelID</p>
<div class="example-wrap"><pre class="language-kotlin"><code>push_manager.unsubscribe(&quot;&quot;)        // Terminate all subscriptions for a user</code></pre></div>
<p>If this function returns <code>false</code> the subsequent <code>verify_connection</code> may result in new channel endpoints.</p>
<h3 id="decrypt-an-incoming-subscription-message"><a href="#decrypt-an-incoming-subscription-message">Decrypt an incoming subscription message</a></h3>
<p>An incoming subscription body will contain a number of metadata elements along with the body of the message. Due to platform differences, how that metadata is provided may //! vary, however the most common form is that the messages “payload” looks like.</p>
<div class="example-wrap"><pre class="language-javascript"><code>{&quot;chid&quot;: &quot;...&quot;,         // ChannelID
 &quot;con&quot;: &quot;...&quot;,          // Encoding form
 &quot;enc&quot;: &quot;...&quot;,          // Optional encryption header
 &quot;crypto-key&quot;: &quot;...&quot;,   // Optional crypto key header
 &quot;body&quot;: &quot;...&quot;,         // Encrypted message body
}</code></pre></div>
<p>These fields may be included as a sub-hash, or may be intermingled with other data fields. If you have doubts or concerns, please contact the Application Services team guidance</p>
<p>Based on the above payload, an example call might look like:</p>
<div class="example-wrap"><pre class="language-kotlin"><code>    val result = manager.decrypt(
        channelID = payload[&quot;chid&quot;].toString(),
        body = payload[&quot;body&quot;].toString(),
        encoding = payload[&quot;con&quot;].toString(),
        salt = payload.getOrElse(&quot;enc&quot;, &quot;&quot;).toString(),
        dh = payload.getOrElse(&quot;dh&quot;, &quot;&quot;).toString()
    )
    // result returns a byte array. You may need to convert to a string
    return result.toString(Charset.forName(&quot;UTF-8&quot;))</code></pre></div></div></details><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.uniffi_reexport_scaffolding.html" title="push::uniffi_reexport_scaffolding macro">uniffi_reexport_scaffolding</a></div><div class="item-right docblock-short"></div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.DispatchInfo.html" title="push::DispatchInfo struct">DispatchInfo</a></div><div class="item-right docblock-short"><p>Dispatch Information returned from <a href="struct.PushManager.html#method.dispatch_info_for_chid" title="PushManager::dispatch_info_for_chid"><code>PushManager::dispatch_info_for_chid</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.InternalPushManager.html" title="push::InternalPushManager struct">InternalPushManager</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.KeyInfo.html" title="push::KeyInfo struct">KeyInfo</a></div><div class="item-right docblock-short"><p>Key Information that can be used to encrypt payloads</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PushConfiguration.html" title="push::PushConfiguration struct">PushConfiguration</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PushManager.html" title="push::PushManager struct">PushManager</a></div><div class="item-right docblock-short"><p>Object representing the PushManager used to manage subscriptions</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PushSubscriptionChanged.html" title="push::PushSubscriptionChanged struct">PushSubscriptionChanged</a></div><div class="item-right docblock-short"><p>An dictionary describing the push subscription that changed, the caller
will receive a list of <a href="struct.PushSubscriptionChanged.html" title="PushSubscriptionChanged"><code>PushSubscriptionChanged</code></a> when calling
<a href="struct.PushManager.html#method.verify_connection" title="PushManager::verify_connection"><code>PushManager::verify_connection</code></a>, one entry for each channel that the
caller should resubscribe to</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SubscriptionInfo.html" title="push::SubscriptionInfo struct">SubscriptionInfo</a></div><div class="item-right docblock-short"><p>Subscription Information, the endpoint to send push messages to and
the key information that can be used to encrypt payloads</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SubscriptionResponse.html" title="push::SubscriptionResponse struct">SubscriptionResponse</a></div><div class="item-right docblock-short"><p>The subscription response object returned from <a href="struct.PushManager.html#method.subscribe" title="PushManager::subscribe"><code>PushManager::subscribe</code></a></p>
</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.BridgeType.html" title="push::BridgeType enum">BridgeType</a></div><div class="item-right docblock-short"><p>The types of supported native bridges.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.PushError.html" title="push::PushError enum">PushError</a></div><div class="item-right docblock-short"></div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Connection.html" title="push::Connection trait">Connection</a></div><div class="item-right docblock-short"><p>A new communication link to the Autopush server</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.InternalStorage.html" title="push::InternalStorage trait">InternalStorage</a></div><div class="item-right docblock-short"></div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.ffi_push_db7d_rustbuffer_alloc.html" title="push::ffi_push_db7d_rustbuffer_alloc fn">ffi_push_db7d_rustbuffer_alloc</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.ffi_push_db7d_rustbuffer_free.html" title="push::ffi_push_db7d_rustbuffer_free fn">ffi_push_db7d_rustbuffer_free</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.ffi_push_db7d_rustbuffer_from_bytes.html" title="push::ffi_push_db7d_rustbuffer_from_bytes fn">ffi_push_db7d_rustbuffer_from_bytes</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.ffi_push_db7d_rustbuffer_reserve.html" title="push::ffi_push_db7d_rustbuffer_reserve fn">ffi_push_db7d_rustbuffer_reserve</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.get_random_bytes.html" title="push::get_random_bytes fn">get_random_bytes</a></div><div class="item-right docblock-short"></div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.InternalResult.html" title="push::InternalResult type">InternalResult</a></div><div class="item-right docblock-short"></div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="push" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.60.0 (7737e0b5c 2022-04-04)" ></div>
</body></html>