initSidebarItems({"constant":[["USER_CONTENT_ROOTS",""]],"enum":[["BookmarkPosition",""],["BookmarkRootGuid","Special GUIDs associated with bookmark roots. It’s guaranteed that the roots will always have these guids."],["InsertableItem",""],["UpdatableItem",""],["UpdateTreeLocation","Support for modifying bookmarks, including changing the location in the tree."]],"fn":[["bookmarks_get_url_for_keyword","Get the URL of the bookmark matching a keyword"],["create_bookmark_roots",""],["delete_bookmark","Delete the specified bookmark. Returns true if a bookmark with the guid existed and was deleted, false otherwise."],["delete_everything","Erases all bookmarks and resets all Sync metadata."],["insert_bookmark",""],["maybe_truncate_title",""],["update_bookmark",""],["update_bookmark_from_info",""]],"mod":[["bookmark_sync",""],["fetch",""],["json_tree",""]],"struct":[["BookmarkUpdateInfo","We don’t require bookmark type for updates on the other side of the FFI, since the type is immutable, and iOS wants to be able to move bookmarks by GUID. We also don’t/can’t enforce as much in the Kotlin/Swift type system as we can/do in Rust."],["InsertableBookmark","Structures which can be used to insert a bookmark, folder or separator."],["InsertableFolder",""],["InsertableSeparator",""],["UpdatableBookmark","Structures which can be used to update a bookmark, folder or separator. Almost all fields are Option<>-like, with None meaning “do not change”. Many fields which can’t be changed by our public API are omitted (eg, guid, date_added, last_modified, etc)"],["UpdatableFolder",""],["UpdatableSeparator",""]]});